---
layout: post
folder: RGB-LEDs
title: Everything I know about RGB LEDs
strapline: blaaaaaaaaaaaah

published: false

categories: [tech]
tags: neopixel led rgb arduino ws2812
---

Intro about how useful they are, especially when designers and clients change their mind.

+ FastLED vs Adafruit Neopixel
+ Different wire protocols 
+ Clones and variants
+


## Tips and trick

### Power handling

Capacitor
`FastLED.setMaxPowerInVoltsAndMilliamps(5, 500);`  

### Timing

Reading sensor or button inputs simultaneously with creating LED animations with `delay()` = no no no.

The FastLED library includes a lot of helper functions for timings, in particular `EVERY_N_MILLIS(x)` and its many variants. For instance:

```c++
EVERY_N_MILLIS(5) { 
   // Update colours on LEDs
   FastLED.show();
}
EVERY_N_SECONDS(5) {
   // Change animation being display
}
```

To create a variable timer, use the macro `EVERY_N_MILLIS_I(my_timer, 5)` and then update it as shown:

```c++
EVERY_N_MILLIS_I(my_timer, 5) { 
   // Do frequent tasks
}
...
my_timer.setPeriod(my_timer.getPeriod()+5);
```

Variants exist with and without the `_I` postfix for: `EVERY_N_MILLIS`, `EVERY_N_SECONDS`, `EVERY_N_BSECONDS`, `EVERY_N_MINUTES`, `EVERY_N_HOURS`.

### Gamma correction

Sometimes really annoying and critical, sometimes nobody cares.

```c++
const uint8_t gamma8[] = {
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  1,  1,  1,  2,  2,  2,  2,  2,  2,  2,
    2,  3,  3,  3,  3,  3,  3,  3,  4,  4,  4,  4,  4,  5,  5,  5,
    5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  9,  9,  9, 10,
   10, 10, 11, 11, 11, 12, 12, 13, 13, 13, 14, 14, 15, 15, 16, 16,
   17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 24, 24, 25,
   25, 26, 27, 27, 28, 29, 29, 30, 31, 32, 32, 33, 34, 35, 35, 36,
   37, 38, 39, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 50,
   51, 52, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 66, 67, 68,
   69, 70, 72, 73, 74, 75, 77, 78, 79, 81, 82, 83, 85, 86, 87, 89,
   90, 92, 93, 95, 96, 98, 99,101,102,104,105,107,109,110,112,114,
  115,117,119,120,122,124,126,127,129,131,133,135,137,138,140,142,
  144,146,148,150,152,154,156,158,160,162,164,167,169,171,173,175,
  177,180,182,184,186,189,191,193,196,198,200,203,205,208,210,213,
  215,218,220,223,225,228,231,233,236,239,241,244,247,249,252,255 };

// Convert values as needed with:
uint8_t corrected_value = gamma8[old_value];
```

To implement with PROGMEM, adapt to:

```c++
const uint8_t PROGMEM gamma8[] = {
    0,  0, ...};

// Convert values:
uint8_t corrected_value = pgm_read_byte(&gamma8[old_value]);
```

### Easing

Lots of very interesting maths in the [lib8tion.h](https://github.com/FastLED/FastLED/blob/master/lib8tion.h) header file. Large comment at the front summarises the functions, and also includes the most helpful remark of the entire file:

```c++
/* Lib8tion is pronounced like 'libation': lie-BAY-shun */
```

Generator function for the data for graphs:

```c++
void setup() { 
   Serial.begin(115200);
   while(!Serial);

   for(uint16_t i=0; i<=255; i++){
      Serial.print(i);
      Serial.print(",");
      Serial.print(sin8(i-64));
      Serial.print(",");
      Serial.print(cubicwave8(i));
      Serial.print(",");
      Serial.print(quadwave8(i));
      Serial.print(",");
      Serial.print(triwave8(i));
      Serial.print(",");
      Serial.print(ease8InOutCubic(i));
      Serial.print(",");
      Serial.print(ease8InOutQuad(i));
      Serial.print(",");
      Serial.println(ease8InOutApprox(i));
   }
```

### Gradients

The quick way to create a gradient across an LED strip is with:

```c++
fill_gradient_RGB(leds,0,CRGB::Red,NUM_LEDS-1, CRGB::Green);
```

However, [gradient palettes](https://github.com/FastLED/FastLED/wiki/Gradient-color-palettes) are the easiest and best way to fade smoothly between two colours, either along a strip or on a single LED. There are two ways to define gradient palettes:

```c++
DEFINE_GRADIENT_PALETTE(my_palette_1_def){
   0,    0,   0,  255,
   90,   0,   255, 0, 
   255,  255, 0,   0
};
CRGBPalette16 my_palette_1 = my_palette_1_def; 

CRGBPalette16 my_palette_2 = CRGBPalette16(
   CRGB(0,  0,   255),
   CRGB(0,  255, 0),
   CRGB(255,0,   0)
);
```

Up to 16 gradients steps are possible. The first option is slower and can't be created dynamically (its saved to PROGMEM) but it allows un-even spacing of gradient steps. To avoid crashes, make sure the final step is always set to 255!

A simple program to fade through the gradient over time on one LED

```c++
uint8_t offset = 0;
EVERY_N_MILLIS(5) { 
   leds[0] = ColorFromPalette(my_palette_2, ++offset);
   FastLED.show();
}
```

The big problem is that the default `ColorFromPalette()` function will scale the gradient so that the entire gradient is pulled using values from 0->240, and then the 240->255 portion of the scale is used to smoothly interpolate from the last value in the gradient back to the first. Useful for circular LED rings, but a pain for any attempts at accurate linear gradient creation.

There are two fixes. One is to define the gradient using type `CRGBPalette256`, the second is to use `scale8()` (like as `map()` or even `map8()`) to compress the 0->255 byte range into 0->240. Here's a demo you can run to see the differences:

```c++
CRGBPalette16 red_blue_red_16 = CRGBPalette16(
   CRGB(0, 0, 0),
   CRGB(255,255,255)
);
CRGBPalette256 red_blue_red_256 = CRGBPalette256(
   CRGB(0, 0, 0),
   CRGB(255,255,255)
);

void setup() { 

   Serial.begin(115200);
   while(!Serial);

   for (int i=0; i<=255; i++) {
      Serial.print(i);
      Serial.print(" | ");
      Serial.print(ColorFromPalette(red_blue_red_16,i).r, HEX);
      Serial.print(" | ");
      Serial.print(ColorFromPalette(red_blue_red_256,i).r, HEX);
      Serial.print(" | ");
      Serial.println(ColorFromPalette(red_blue_red_16,scale8(i,240)).r, HEX);
   }
}
```

Both approaches work, but when functions accept it as an argument (see below) `CRGBPalette256` gives the smoothest possible interpolation. More discussion of this point contained in [this Reddit thread](https://www.reddit.com/r/FastLED/comments/fx6w94/colorfrompalette_incorrectly_mapping_across_0240/).

Fading between gradients is done with `nblendPaletteTowardPalette()`. For example:

```c++

```




# https://github.com/atuline/FastLED-Demos

    Do NOT use delay statements in the loop as that breaks input routines (i.e. button).
    Do not use nested loops (for performance reasons).
    Use millis() as a real time counter unless a fixed counter is required.
    Spend a bit more time using high school math (ie trigonometry), rather than just count pixels.
    Keep the display routines as short as possible.
    Data typing as strict as possible i.e. why define an int when a uint8_t is all that is required. Oh, and floats are not used at all.
    Localize variables to each routine as much as possible.
    Break out the display routines into separate .h files for increased readability and modularity.
    Be generous with comments.
